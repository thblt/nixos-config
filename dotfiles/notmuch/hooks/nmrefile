#! /usr/bin/env nix-shell
#! nix-shell -i python -p python3Packages.notmuch2 python3
#
# A slightly paranoid notmuch/mbsync mail refiling/retagging script.
# This isn’t a general solution.
#
# This program does three things, order of operations matter!
#
# - `nmrefile refile` must run in `pre-new`, and in any case BEFORE
#   mbsync so it can move mails, matching maildirs to notmuch tags.
#
# - `nmrefile retag` must run in `post-new`, and in any case AFTER
#   mbsync, so it can adjust tag to maildir folders (to reflect
#   changes that may have been done from a maildir-based client)
#
# - `nmrefile lost` can run at any point.  All it does is add the
#   `lost` tag to messages that don’t have at least one account tag
#   and one folder tag.  Notice it only *adds* the tag: `retag`
#   removes it.

import argparse
import os
import re
import shutil
import sys
from pathlib import Path

import notmuch2

#################
# CONFIGURATION #
#################

# List of account tags/imap folders (those must be the same)
ACCOUNTS = {"work", "personal"}

# dict of folder tags and real folder names.
# This works because all my accounts use the same folder names,
# but more complexe setups may require a more complex function.
FOLDERS = {
    "inbox": "Inbox",
    "sent": "Sent",
    "spam": "Junk",
    "drafts": "Drafts",
    "archive": "Archive",
    "deleted": "Trash",
}

# Tag to remove after a message has been correctly tagged.
TAG_NEW = "new"

# Tag to identify lost messages
TAG_LOST = "lost"

# In REFILER MODE, if a message has a tag in this list, its processing
# stops immediately.
POISONED_TAGS = [TAG_NEW, TAG_LOST]


##########
# REFILE #
##########


def prepare_refile_plan(msg):
    """The main function of the dwim refiler.

    Compute a plan (a series of file copies and a series of deletions)
    so that msg ends up in the correct IMAP folders.
    """

    # List all tags from the message.
    tags = set(msg.tags)

    info(f"  Message has tags: {repr_tags(tags)}")
    # Check that the message doesn’t have any dangerous tags.
    if [tag for tag in tags if tag in POISONED_TAGS]:
        error("  Message contains poisoned tags!")
        return None

    # Tags come in pair: account tags (work, personal), and folder
    # tags (inbox, archive...)
    msg_acc_tags = {tag for tag in tags if tag in ACCOUNTS}
    msg_folder_tags = {tag for tag in tags if tag in FOLDERS.keys()}

    # Build all possible pairs of tags from the account and folder
    # tags in that message.  This determines the full list of IMAP
    # copies of that message that must exist.  For example, if a
    # message has the (work, archive) pair, there must be a copy of
    # it in /work/Archive/.
    all_msg_pairs = list()
    for acc in msg_acc_tags:
        for folder in msg_folder_tags:
            all_msg_pairs.append((acc, folder))
    all_msg_pairs = set(all_msg_pairs)  # TODO Use set comprehension

    info(
        f"  Refiling with tags {repr_tags(tags)}. File into: [{repr_pairs(all_msg_pairs)}]"
    )

    # If all_msg_pairs is empty, we’re about to destroy that message.
    # This should never happen if main() does its job correctly.
    # But we make sure to abort before it happens.
    if not all_msg_pairs:
        error("  No destination for this message (is it lost?).  Aborting.")
        return None

    # Get list of actual copies of that messages, as paths in the
    # maildir store.
    filenames = list(msg.filenames())
    assert len(filenames) > 0

    # Associate existing files with (account, folder) tag pairs.
    # for example, file /home/thblt/.mail/work/Archive/..." corresponds
    # to the (work, archive) tag pair.
    existing_files = dict()
    for fn in filenames:
        (file_acc, file_folder) = path_to_tags(fn)
        info(f"  ({file_acc},{file_folder}) exists at {fn}")
        existing_files[(file_acc, file_folder)] = fn

    # Start deciding what to do.  At this point, we only work with tag
    # pairs.

    # These are the tag pairs describing copies that already exist.
    existing_pairs = set(existing_files.keys())

    # Another check: the accounts in existing_pair must be the same in
    # msg_acc_tags: we don’t work accross account boundaries (but a
    # message may be in multiple accounts!)
    if msg_acc_tags != {acc for (acc, _) in existing_pairs}:
        error(
            "  Account tags and maildir files don’t match.  Aborting to respect account boundaries."
        )
        return None

    satisfied_folder_tags = {tag for (_, tag) in existing_pairs}
    unsatisfied_folder_tags = {
        tag for tag in msg_folder_tags if not tag in satisfied_folder_tags
    }

    # Things that exist but aren’t wanted will be deleted.
    delete_pairs = existing_pairs - all_msg_pairs

    possible_pairs = all_msg_pairs - existing_pairs

    create_pairs = set()
    # Now we need to decide where to create new copies.  We can’t just
    # create every file in all_msg_pairs, because the self-mail from
    # one account to another issue.  We first enumerate the accounts
    # from which we will delete files:
    for account in {acc for (acc, _) in delete_pairs}:
        # And then we add all possible pairs for that account.
        create_pairs = create_pairs.union(
            {
                (acc, folder)
                for (acc, folder) in possible_pairs
                if acc == account and not (folder in satisfied_folder_tags)
            }
        )

    # Identify folder tags that remain unsatisfied:
    still_unsatisfied = {
        tag
        for tag in unsatisfied_folder_tags
        if not tag in {fldr for (_, fldr) in create_pairs}
    }
    if still_unsatisfied:
        notice(
            f"  Plan will not satisfy folder tags {still_unsatisfied}.  Message may be overtagged."
        )

    # Show the plan before the last checks.
    info(
        f"  Plan is: create [{repr_pairs(create_pairs)}], delete [{repr_pairs(delete_pairs)}]"
    )

    # Consistency check.  This is not a mail multiplicator, but a
    # mover.  We tnhus want to have exactly as many deletions than
    # creations, on each account.  The user can override this (with
    # caution!) if a mail somehow ended up in too many folders.
    for account in ACCOUNTS:
        copies = len(
            [(acc, folder) for (acc, folder) in create_pairs if acc == account]
        )
        deletions = len(
            [(acc, folder) for (acc, folder) in delete_pairs if acc == account]
        )
        if not ((ALLOW_EXTRA_DELETE and deletions > copies) or copies == deletions):
            error(
                f"  Plan would create {copies} new copies in {account}, but delete {deletions}.  Use --extra-delete (with caution!) to allow that."
            )

    # Absolute sanity check: we must NOT delete all copies of a
    # message.  This is an integrity check: it’s a bug if this
    # happens.
    if not (existing_pairs - delete_pairs).union(create_pairs):
        error("  FUCK.  This plan would not preserve any copy.  THIS IS A BUG.")
        return None

    # Sanity check.  There must be no intersection between the sets.
    # And the intersection of the sets must be empty
    assert not existing_pairs.intersection(create_pairs)
    assert not delete_pairs.intersection(create_pairs)
    assert not delete_pairs - existing_pairs

    if not (delete_pairs or create_pairs):
        return None

    copy_from = filenames[0]
    copy_plan = [(copy_from, tags_to_path(acc, fldr)) for (acc, fldr) in create_pairs]

    delete_plan = [
        path for (pair, path) in existing_files.items() if pair in delete_pairs
    ]

    assert copy_plan or delete_plan
    return copy_plan, delete_plan


def execute_refile_plan(msg, copy_plan, delete_plan):
    copy = []
    for source, dest_dir in copy_plan:
        dest_name = re.sub(",U=[0-9]+", "", source.name)
        if source.name == dest_name:
            notice(
                "  Source and destination names are identical. This may happen if you move the same message multiple times before running mbsync."
            )
        dest = dest_dir / dest_name
        assert os.path.exists(source) and os.path.isfile(source)
        assert not os.path.exists(dest)
        copy.append((str(source), str(dest)))

    for path in delete_plan:
        assert os.path.exists(path)
        assert os.path.isfile(path)

    info("  Executing plan...")

    for source, dest in copy:
        log(f"  Copy {source} => {dest}")
        if not SIMULATE:
            shutil.copy2(source, dest)
            DATABASE.add(dest)

    for path in delete_plan:
        log(f"  Delete {path}")
        if not SIMULATE:
            os.unlink(path)
            DATABASE.remove(path)


def do_refile(msg):
    plan = prepare_refile_plan(msg)
    if plan:
        execute_refile_plan(msg, plan[0], plan[1])
        log(f"Done {msg.messageid}.")
        return 1
    else:
        info(f"  No refile plan, doing nothing.")
        return 0


def main_refile():
    log("Refiler mode.")
    (found, modified) = run_queries(do_refile)
    log(f"Refile done.  {found} messages processed, {modified} refiled.")


#########
# RETAG #
#########


def do_retag(msg):
    # Get message tags, and select only those we can work with
    # (including TAG_NEW and TAG_LOST, which we’ll want to remove)
    msg_tags = {tag for tag in msg.tags if tag in KNOWN_TAGS.union({TAG_NEW, TAG_LOST})}

    # Enumerate tags this message should have, based on filesystem
    # paths.
    expected_tags = list()
    for fn in msg.filenames():
        (acc, folder) = path_to_tags(fn)
        expected_tags.append(acc)
        expected_tags.append(folder)
    expected_tags = set(expected_tags)

    # We should have at least one folder and one account tag.
    assert expected_tags.intersection(FOLDER_TAGS)
    assert expected_tags.intersection(ACCOUNTS)

    # Compute which tags should be added or removed.
    add_tags = expected_tags - msg_tags
    remove_tags = msg_tags - expected_tags

    # Make sure there’s no intersection
    assert not add_tags.intersection(remove_tags)

    if add_tags or remove_tags:
        notice(f"Retag: {repr_tags(remove_tags, '-')} {repr_tags(add_tags, '+')}")

        if not SIMULATE:
            for tag in add_tags:
                msg.tags.add(tag)
            for tag in remove_tags:
                msg.tags.discard(tag)

        return True

    return False


def main_retag():
    log("Retag/initial tagging mode.")
    found, modified = run_query(f"tag:{TAG_NEW} or tag:{TAG_LOST}", do_retag)
    found2, modified2 = run_queries(do_retag)
    log(f"Retagging done.  {found} messages processed, {modified} updated.")



########
# LOST #
########

def main_lost():
    log("Lost mode.")

    any_acc = " or ".join({"tag:" + acc for acc in ACCOUNTS})
    any_folder = " or ".join({"tag:" + folder for folder in FOLDER_TAGS})
    # Messages that aren’t lost.
    not_lost_query = f"({any_acc}) and ({any_folder})"
    # Messages that ARE lost.
    lost_query = f"not ({not_lost_query})"
    # # Messages that WERE lost but aren’t.
    # unlost_query = f"tag:{TAG_LOST} and ({not_lost_query})"

    def tag_lost(msg):
        notice("  Message is lost (tagged +lost).")
        if not SIMULATE:
            msg.tags.add(TAG_LOST)
        return True

    # def untag_lost(msg):
    #     notice("  Message isn’t lost anymore (tagged -lost).")
    #     if not SIMULATE:
    #         msg.tags.discard(TAG_LOST)
    #     return True

    # (unlost_count, _) = run_query(unlost_query, untag_lost)
    (lost_count, _) = run_query(lost_query, tag_lost)

    if lost_count > 0:
        notice(f"There is/are {lost_count} lost message(s).")
    else:
        log("No newly lost messages.")



#########################
# COMMON INFRASTRUCTURE #
#########################


def run_queries(handler):
    """This function generate queries to identify misplaced messages,
    and passes them to handler, a one-argument function.

    TODO This should probably be a generator!
    """
    found = 0
    modified = 0
    for folder_tag, folder_name in FOLDERS.items():
        for acc in ACCOUNTS:
            # Build a query looking for messages whose paths don’t
            # match tags.
            query = f"(tag:{acc} and tag:{folder_tag}) xor folder:/{acc}/{folder_name}/"
            (f, m) = run_query(query, handler)
            found += f
            modified += m

    return found, modified


def run_query(query, handler):
    """Execute QUERY and pass each message in turn to handler."""
    info(f"Running query {query}")
    found = 0
    modified = 0
    # Run this query on database
    for msg in DATABASE.messages(query):
        found += 1
        log_start(f"* Processing {msg.messageid}")
        if handler(msg):
            modified += 1

    return (found, modified)


def tags_to_path(account, folder):
    """Return a path (relative to maildir root) based on an account and a folder tag."""
    return ROOT / account / FOLDERS[folder] / "new"


def path_to_tags(path):
    """Compute tags for a given path.  This will return either a pair
    or None, check the output (at least by deconstructing the pair)
    """
    parts = path.relative_to(ROOT).parts
    if len(parts) != 4:
        error(
            f"Path {path} expands to {len(parts)} components relatively to root, expected 4."
        )
        return None
    file_acc = parts[0] if parts[0] in ACCOUNTS else None
    file_folder = FOLDERS_REV.get(parts[1])
    assert parts[2] in {"cur", "new"}

    if file_acc and file_folder:
        return (file_acc, file_folder)
    else:
        error(f"Cannot convert path {fn} to tags. Acc={file_acc}, folder={file_folder}")
        return None


######
# UI #
######


def repr_pairs(pairs):
    return ", ".join([repr_pair(pair) for pair in pairs])


def repr_pair(pair):
    return f"({pair[0]},{pair[1]})"


def repr_tags(tags, prefix=""):
    return " ".join(prefix + tag for tag in tags)


COLOR_GREEN = "\033[0;32m"
COLOR_RED = "\033[0;31m"
COLOR_YELLOW = "\033[1;33m"
COLOR_BOLD = "\033[1m"
COLOR_FAINT = "\033[2m"
COLOR_END = "\033[0m"
COLOR_LIGHT_GRAY = "\033[0;37m"


def info(message):
    if VERBOSE:
        print_line(message, color=COLOR_FAINT)


def log(message):
    print_line(message)


def log_start(message):
    print_line(message, color=COLOR_BOLD + COLOR_GREEN)


def notice(message):
    print_line(message, color=COLOR_BOLD + COLOR_YELLOW)


def error(message):
    print_line(message, color=COLOR_BOLD + COLOR_RED)


def print_line(message, color=""):
    print(f"[nmrefile]{color} {message}{COLOR_END}")


###########
# STARTUP #
###########

def main(argv=sys.argv[1:]):
    global VERBOSE, SIMULATE, DATABASE, ROOT

    argparser = argparse.ArgumentParser(description="DWIM refiler for notmuch")

    argparser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable extra debug output"
    )
    argparser.add_argument(
        "--dry-run", action="store_true", help="Don’t actually modify anything."
    )

    argsubparsers = argparser.add_subparsers(title="Commands", dest="command")
    argsubparsers.required = True

    argsp = argsubparsers.add_parser(
        "refile", help="Refile messages in maildir folders based on tags"
    )
    argsp.add_argument(
        "--extra-delete",
        help="Let the refiler delete more copies than it creates (use with caution!)",
    )
    argsubparsers.add_parser(
        "retag", help="Update tags on messages based on maildir locations"
    )
    argsubparsers.add_parser("lost", help="Identify lost messages")

    args = argparser.parse_args(argv)

    VERBOSE = args.verbose
    SIMULATE = args.dry_run

    info("Opening notmuch database...")
    # The notmuch database itself.  This may block, so don’t set it
    # before
    DATABASE = notmuch2.Database(mode=notmuch2.Database.MODE.READ_WRITE)

    # Maildir root
    ROOT = Path(DATABASE.config["database.path"])



    match args.command:
        case "refile":
            main_refile()
        case "retag":
            main_retag()
        case "lost":
            main_lost()


if __name__ == "__main__":
    # Build the reverse dict
    FOLDERS_REV = {v: k for k, v in FOLDERS.items()}

    # Enable verbose output
    VERBOSE = False

    # If true, don’t do anything
    SIMULATE = False

    # If true, allow deletion of more copies than we create.  This is
    # useful in the rare case where a mail has more copies than needed.
    ALLOW_EXTRA_DELETE = False

    FOLDER_TAGS = set(FOLDERS.keys())
    KNOWN_TAGS = ACCOUNTS.union(FOLDER_TAGS)

    # The notmuch database, set by main.
    DATABASE = None

    # Maildir root, set by main.
    ROOT = None

    main()
